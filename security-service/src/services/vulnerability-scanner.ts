/**
 * Vulnerability Scanner Service
 * Automated vulnerability scanning and assessment
 */

import { logger } from '@universal-ai-cs/shared';
import axios from 'axios';

export interface VulnerabilityScan {
  id: string;
  organizationId: string;
  scanType: 'quick' | 'full' | 'targeted';
  targets: string[];
  status: 'pending' | 'running' | 'completed' | 'failed' | 'cancelled';
  startedAt: Date;
  completedAt?: Date;
  progress: number;
  options: {
    depth: 'shallow' | 'standard' | 'deep';
    includeInformational: boolean;
    customRules?: string[];
  };
  metadata: {
    totalChecks: number;
    completedChecks: number;
    estimatedTimeRemaining?: number;
  };
}

export interface Vulnerability {
  id: string;
  cveId?: string;
  name: string;
  description: string;
  severity: 'info' | 'low' | 'medium' | 'high' | 'critical';
  category: string;
  location: {
    service: string;
    endpoint?: string;
    file?: string;
    line?: number;
  };
  evidence: string[];
  remediation: {
    description: string;
    steps: string[];
    priority: number;
    estimatedEffort: string;
  };
  cvss: {
    score: number;
    vector: string;
    exploitability: number;
    impact: number;
  };
  discoveredAt: Date;
  status: 'open' | 'acknowledged' | 'fixed' | 'false_positive';
}

export interface ScanResult {
  scanId: string;
  organizationId: string;
  completedAt: Date;
  vulnerabilities: Vulnerability[];
  summary: {
    total: number;
    bySeverity: Record<string, number>;
    byCategory: Record<string, number>;
    riskScore: number;
  };
  recommendations: Array<{
    priority: number;
    description: string;
    impact: string;
    effort: string;
  }>;
}

export class VulnerabilityScanner {
  private static instance: VulnerabilityScanner;
  private activeScans: Map<string, VulnerabilityScan> = new Map();
  private scanResults: Map<string, ScanResult> = new Map();
  private vulnerabilityRules: Map<string, any> = new Map();
  private periodicScanInterval?: NodeJS.Timeout;

  private constructor() {}

  public static getInstance(): VulnerabilityScanner {
    if (!VulnerabilityScanner.instance) {
      VulnerabilityScanner.instance = new VulnerabilityScanner();
    }
    return VulnerabilityScanner.instance;
  }

  /**
   * Initialize the vulnerability scanner
   */
  public async initialize(): Promise<void> {
    try {
      await this.loadVulnerabilityDatabase();
      this.startPeriodicScans();
      
      logger.info('Vulnerability Scanner initialized', {
        vulnerabilityRules: this.vulnerabilityRules.size,
        periodicScansEnabled: true,
      });
    } catch (error) {
      logger.error('Failed to initialize Vulnerability Scanner', {
        error: error instanceof Error ? error.message : String(error),
      });
      throw error;
    }
  }

  /**
   * Start a vulnerability scan
   */
  public async startScan(scanConfig: {
    organizationId: string;
    scanType: 'quick' | 'full' | 'targeted';
    targets: string[];
    options: {
      depth: 'shallow' | 'standard' | 'deep';
      includeInformational: boolean;
      customRules?: string[];
    };
  }): Promise<string> {
    try {
      const scanId = `scan_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
      
      const scan: VulnerabilityScan = {
        id: scanId,
        organizationId: scanConfig.organizationId,
        scanType: scanConfig.scanType,
        targets: scanConfig.targets,
        status: 'pending',
        startedAt: new Date(),
        progress: 0,
        options: scanConfig.options,
        metadata: {
          totalChecks: this.calculateTotalChecks(scanConfig),
          completedChecks: 0,
        },
      };

      this.activeScans.set(scanId, scan);

      // Start scan asynchronously
      this.executeScan(scanId).catch(error => {
        logger.error('Scan execution failed', {
          scanId,
          error: error instanceof Error ? error.message : String(error),
        });
      });

      logger.info('Vulnerability scan started', {
        scanId,
        organizationId: scanConfig.organizationId,
        scanType: scanConfig.scanType,
        targets: scanConfig.targets,
      });

      return scanId;
    } catch (error) {
      logger.error('Error starting vulnerability scan', {
        error: error instanceof Error ? error.message : String(error),
        organizationId: scanConfig.organizationId,
      });
      throw error;
    }
  }

  /**
   * Get scan status
   */
  public async getScanStatus(scanId: string): Promise<VulnerabilityScan | null> {
    return this.activeScans.get(scanId) || null;
  }

  /**
   * Get scan results
   */
  public async getScanResults(scanId: string): Promise<ScanResult | null> {
    return this.scanResults.get(scanId) || null;
  }

  /**
   * Get vulnerabilities for organization
   */
  public async getVulnerabilities(
    organizationId: string,
    filters?: {
      severity?: string;
      category?: string;
      status?: string;
      limit?: number;
    }
  ): Promise<Vulnerability[]> {
    try {
      let vulnerabilities: Vulnerability[] = [];

      // Collect vulnerabilities from all scan results
      for (const result of this.scanResults.values()) {
        if (result.organizationId === organizationId) {
          vulnerabilities.push(...result.vulnerabilities);
        }
      }

      // Apply filters
      if (filters) {
        if (filters.severity) {
          vulnerabilities = vulnerabilities.filter(v => v.severity === filters.severity);
        }
        if (filters.category) {
          vulnerabilities = vulnerabilities.filter(v => v.category === filters.category);
        }
        if (filters.status) {
          vulnerabilities = vulnerabilities.filter(v => v.status === filters.status);
        }
      }

      // Sort by severity and discovery date
      vulnerabilities.sort((a, b) => {
        const severityOrder = { critical: 5, high: 4, medium: 3, low: 2, info: 1 };
        const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
        if (severityDiff !== 0) return severityDiff;
        return b.discoveredAt.getTime() - a.discoveredAt.getTime();
      });

      // Apply limit
      if (filters?.limit) {
        vulnerabilities = vulnerabilities.slice(0, filters.limit);
      }

      return vulnerabilities;
    } catch (error) {
      logger.error('Error getting vulnerabilities', {
        error: error instanceof Error ? error.message : String(error),
        organizationId,
      });
      return [];
    }
  }

  /**
   * Update vulnerability status
   */
  public async updateVulnerabilityStatus(
    vulnerabilityId: string,
    status: 'open' | 'acknowledged' | 'fixed' | 'false_positive',
    notes?: string
  ): Promise<void> {
    try {
      // Find and update vulnerability across all scan results
      for (const result of this.scanResults.values()) {
        const vulnerability = result.vulnerabilities.find(v => v.id === vulnerabilityId);
        if (vulnerability) {
          vulnerability.status = status;
          (vulnerability as any).statusUpdatedAt = new Date();
          (vulnerability as any).statusNotes = notes;
          
          logger.info('Vulnerability status updated', {
            vulnerabilityId,
            status,
            notes,
          });
          return;
        }
      }

      throw new Error('Vulnerability not found');
    } catch (error) {
      logger.error('Error updating vulnerability status', {
        error: error instanceof Error ? error.message : String(error),
        vulnerabilityId,
        status,
      });
      throw error;
    }
  }

  /**
   * Cancel a running scan
   */
  public async cancelScan(scanId: string): Promise<void> {
    try {
      const scan = this.activeScans.get(scanId);
      if (!scan) {
        throw new Error('Scan not found');
      }

      if (scan.status === 'running') {
        scan.status = 'cancelled';
        scan.completedAt = new Date();
        
        logger.info('Vulnerability scan cancelled', { scanId });
      }
    } catch (error) {
      logger.error('Error cancelling scan', {
        error: error instanceof Error ? error.message : String(error),
        scanId,
      });
      throw error;
    }
  }

  /**
   * Shutdown the scanner
   */
  public async shutdown(): Promise<void> {
    try {
      if (this.periodicScanInterval) {
        clearInterval(this.periodicScanInterval);
      }

      // Cancel running scans
      for (const [scanId, scan] of this.activeScans.entries()) {
        if (scan.status === 'running') {
          scan.status = 'cancelled';
          scan.completedAt = new Date();
        }
      }

      logger.info('Vulnerability Scanner shut down');
    } catch (error) {
      logger.error('Error shutting down Vulnerability Scanner', {
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  /**
   * Health check
   */
  public async healthCheck(): Promise<{
    status: 'healthy' | 'degraded' | 'unhealthy';
    scansRunning: number;
    lastScanTime?: Date;
    scannerHealth: boolean;
  }> {
    try {
      const runningScans = Array.from(this.activeScans.values()).filter(scan => scan.status === 'running');
      const completedScans = Array.from(this.scanResults.values());
      const lastScan = completedScans.sort((a, b) => b.completedAt.getTime() - a.completedAt.getTime())[0];

      return {
        status: 'healthy',
        scansRunning: runningScans.length,
        lastScanTime: lastScan?.completedAt,
        scannerHealth: true,
      };
    } catch (error) {
      logger.error('Vulnerability scanner health check failed', {
        error: error instanceof Error ? error.message : String(error),
      });
      
      return {
        status: 'unhealthy',
        scansRunning: 0,
        scannerHealth: false,
      };
    }
  }

  // Private helper methods
  private async loadVulnerabilityDatabase(): Promise<void> {
    // Load common vulnerability patterns
    const vulnerabilities = [
      {
        id: 'CVE-2023-XXXX',
        name: 'SQL Injection in User Input',
        description: 'Potential SQL injection vulnerability in user input fields',
        severity: 'high' as const,
        category: 'injection',
        pattern: /(union|select|insert|delete|update|drop)\s+/i,
        remediation: 'Use parameterized queries and input validation',
      },
      {
        id: 'CVE-2023-YYYY',
        name: 'Cross-Site Scripting (XSS)',
        description: 'Potential XSS vulnerability in output rendering',
        severity: 'medium' as const,
        category: 'xss',
        pattern: /<script[^>]*>.*?<\/script>/gi,
        remediation: 'Implement proper output encoding and CSP headers',
      },
    ];

    vulnerabilities.forEach(vuln => {
      this.vulnerabilityRules.set(vuln.id, vuln);
    });
  }

  private startPeriodicScans(): void {
    // Run periodic scans every 24 hours
    this.periodicScanInterval = setInterval(async () => {
      try {
        logger.info('Starting periodic vulnerability scan');
        
        // Get all organizations for scanning
        const organizations = await this.getAllOrganizations();
        
        for (const orgId of organizations) {
          await this.startScan({
            organizationId: orgId,
            scanType: 'full',
            targets: ['web', 'api', 'database'],
            options: {
              depth: 'standard',
              includeInformational: false,
            },
          });
        }
      } catch (error) {
        logger.error('Error in periodic vulnerability scan', {
          error: error instanceof Error ? error.message : String(error),
        });
      }
    }, 24 * 60 * 60 * 1000); // 24 hours
  }

  private async getAllOrganizations(): Promise<string[]> {
    // In production, this would query the database
    return ['default-org'];
  }

  private calculateTotalChecks(scanConfig: any): number {
    let baseChecks = 50; // Base number of checks
    
    if (scanConfig.scanType === 'full') {
      baseChecks *= 3;
    } else if (scanConfig.scanType === 'targeted') {
      baseChecks *= 1.5;
    }
    
    if (scanConfig.options.depth === 'deep') {
      baseChecks *= 2;
    } else if (scanConfig.options.depth === 'shallow') {
      baseChecks *= 0.5;
    }
    
    return Math.round(baseChecks * scanConfig.targets.length);
  }

  private async executeScan(scanId: string): Promise<void> {
    const scan = this.activeScans.get(scanId);
    if (!scan) return;

    try {
      scan.status = 'running';
      scan.startedAt = new Date();

      const vulnerabilities: Vulnerability[] = [];
      const totalChecks = scan.metadata.totalChecks;

      // Simulate scan execution
      for (let i = 0; i < totalChecks; i++) {
        if (scan.status === 'cancelled') {
          return;
        }

        // Simulate vulnerability detection (random for demo)
        if (Math.random() < 0.1) { // 10% chance of finding vulnerability
          const vuln = this.generateMockVulnerability(scan.organizationId);
          vulnerabilities.push(vuln);
        }

        scan.metadata.completedChecks = i + 1;
        scan.progress = Math.round((i + 1) / totalChecks * 100);

        // Simulate processing time
        await new Promise(resolve => setTimeout(resolve, 100));
      }

      // Complete scan
      scan.status = 'completed';
      scan.completedAt = new Date();
      scan.progress = 100;

      // Store results
      const result: ScanResult = {
        scanId,
        organizationId: scan.organizationId,
        completedAt: new Date(),
        vulnerabilities,
        summary: this.generateSummary(vulnerabilities),
        recommendations: this.generateRecommendations(vulnerabilities),
      };

      this.scanResults.set(scanId, result);

      logger.info('Vulnerability scan completed', {
        scanId,
        vulnerabilitiesFound: vulnerabilities.length,
        duration: Date.now() - scan.startedAt.getTime(),
      });

    } catch (error) {
      scan.status = 'failed';
      scan.completedAt = new Date();
      
      logger.error('Vulnerability scan failed', {
        scanId,
        error: error instanceof Error ? error.message : String(error),
      });
    }
  }

  private generateMockVulnerability(organizationId: string): Vulnerability {
    const vulnerabilityTypes = [
      {
        name: 'SQL Injection',
        category: 'injection',
        severity: 'high' as const,
        description: 'Potential SQL injection vulnerability detected',
      },
      {
        name: 'Cross-Site Scripting',
        category: 'xss',
        severity: 'medium' as const,
        description: 'Potential XSS vulnerability detected',
      },
      {
        name: 'Insecure Direct Object Reference',
        category: 'authorization',
        severity: 'high' as const,
        description: 'Direct object access without proper authorization',
      },
    ];

    const type = vulnerabilityTypes[Math.floor(Math.random() * vulnerabilityTypes.length)];
    
    return {
      id: `vuln_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      name: type.name,
      description: type.description,
      severity: type.severity,
      category: type.category,
      location: {
        service: 'api-gateway',
        endpoint: '/api/v1/test',
      },
      evidence: ['Request pattern analysis', 'Response validation'],
      remediation: {
        description: 'Implement proper input validation and sanitization',
        steps: [
          'Review input validation logic',
          'Implement parameterized queries',
          'Add output encoding',
          'Test security controls',
        ],
        priority: type.severity === 'high' ? 1 : 2,
        estimatedEffort: '2-4 hours',
      },
      cvss: {
        score: type.severity === 'high' ? 7.5 : 5.0,
        vector: 'CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N',
        exploitability: 3.9,
        impact: 3.6,
      },
      discoveredAt: new Date(),
      status: 'open',
    };
  }

  private generateSummary(vulnerabilities: Vulnerability[]): any {
    const bySeverity: Record<string, number> = {};
    const byCategory: Record<string, number> = {};

    vulnerabilities.forEach(vuln => {
      bySeverity[vuln.severity] = (bySeverity[vuln.severity] || 0) + 1;
      byCategory[vuln.category] = (byCategory[vuln.category] || 0) + 1;
    });

    const riskScore = this.calculateRiskScore(vulnerabilities);

    return {
      total: vulnerabilities.length,
      bySeverity,
      byCategory,
      riskScore,
    };
  }

  private calculateRiskScore(vulnerabilities: Vulnerability[]): number {
    if (vulnerabilities.length === 0) return 0;

    const severityWeights = { critical: 10, high: 7, medium: 4, low: 2, info: 1 };
    const totalWeight = vulnerabilities.reduce((sum, vuln) => sum + severityWeights[vuln.severity], 0);
    
    return Math.min(100, Math.round(totalWeight / vulnerabilities.length * 10));
  }

  private generateRecommendations(vulnerabilities: Vulnerability[]): any[] {
    const recommendations = [
      {
        priority: 1,
        description: 'Implement comprehensive input validation',
        impact: 'Prevents injection attacks',
        effort: '1-2 weeks',
      },
      {
        priority: 2,
        description: 'Enable security headers',
        impact: 'Reduces XSS and other client-side attacks',
        effort: '1-2 days',
      },
      {
        priority: 3,
        description: 'Regular security testing',
        impact: 'Early detection of vulnerabilities',
        effort: 'Ongoing',
      },
    ];

    return recommendations.slice(0, Math.min(5, vulnerabilities.length + 1));
  }
}
